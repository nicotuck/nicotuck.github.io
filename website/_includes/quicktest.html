<!DOCTYPE html>
<html>

<head>
    <title>Wheel Rolling</title>
    <style>
        body {
            padding: 0;
            margin: 0;
        }

        #draw-area {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>
    <div id="draw-area"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.10/two.min.js"
        integrity="sha512-D9pUm3+gWPkv/Wl6vd45vRLjdkdEKGje7BxOxYG0N6m4UlEUB7RSljBwpmJNAOuf6txLLtlaRchoKfzngr/bQg=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</body>
<script>

    const inst = new p5(p => {
        p.setup = function () { };
    });

    // Set up the Two.js drawing
    const two = new Two({
        fullscreen: true,
        autostart: false
    }).appendTo(document.getElementById('draw-area'));

    // Set up Matter.js physics
    const engine = Matter.Engine.create();
    const world = engine.world;
    const runner = Matter.Runner.create();

    // Set up the wheel
    const wheelRadius = 100;
    const wheel = Matter.Bodies.circle(
        two.width / 2, two.height / 2, wheelRadius, {
        friction: 0.9,
        restitution: 0.4,
        density: 0.1,
        label: "wheel",
    });
    const wheelGraphic = two.makeCircle(wheel.position.x, wheel.position.y, wheelRadius);
    Matter.World.add(world, wheel);

    // Set up the dummy body
    const dummy = Matter.Bodies.rectangle(wheel.position.x, two.height, 1, 1, { isStatic: true });
    Matter.World.add(world, dummy);

    // Connect the wheel and dummy with a spring
    const spring = Matter.Constraint.create({
        bodyA: wheel,
        bodyB: dummy,
        stiffness: 0.05,
        damping: 0.001
    });
    Matter.World.add(world, spring);

    // Set up the terrain
    const terrainPoints = []
    let noise_x = 0;
    let noise_step = 0.5;

    function add_new_terrain_body() {
        const lastPoint = terrainPoints[terrainPoints.length - 2];
        const newPoint = terrainPoints[terrainPoints.length - 1];
        const segment = Matter.Bodies.rectangle(
            (lastPoint.x + newPoint.x) / 2, (lastPoint.y + newPoint.y) / 2,
            Math.hypot(newPoint.x - lastPoint.x, newPoint.y - lastPoint.y),
            10, { isStatic: true });
        Matter.World.add(world, segment);
    }
    for (let x = 0; x <= 1.1 * two.width; x += two.width / 20) {
        terrainPoints.push(
            new Two.Anchor(x, 100 * inst.noise(noise_x)));
        if (terrainPoints.length > 1) {
            add_new_terrain_body();
        }
        noise_x += noise_step;
    }
    // console.log(terrainPoints.map(tp => [tp.x, tp.y]))
    const terrainGraphic = two.makePath(terrainPoints);
    terrainGraphic.closed = false;
    terrainGraphic.linewidth = 4;
    // terrainGraphic.translation.set(
    //     0 - terrainGraphic.getBoundingClientRect(true).left,
    //     two.height - 100);
    // Matter.Body.translation()
    box = new Two.Rectangle(0, 0, 20, 20);
    box.fill = '#000000';
    two.add(box);


    const frame_vec = Matter.Vector.create(-5, 0);
    var lastTime;
    function animate(now) {
        requestAnimationFrame(animate);
        if (!lastTime) { lastTime = now; }
        var elapsed = now - lastTime;
        Matter.Engine.update(engine, elapsed);

        // Update wheel position
        wheelGraphic.translation.set(wheel.position.x, wheel.position.y);

        terrainGraphic.vertices = terrainPoints;

        // Remove old terrain segments that have scrolled off the screen
        if (terrainPoints[0].x <= -two.width / 10) {
            // console.log(terrainPoints.map(tp => [tp.x, tp.y]))
            terrainPoints.shift();
            offset = terrainPoints[0].x;
            terrainPoints.push(
                new Two.Anchor(1.1 * two.width + offset, 100 * inst.noise(noise_x)));
            add_new_terrain_body()
            Matter.World.remove(world, world.bodies[0]);

        }

        // Scroll the terrain and the wheel to simulate the wheel moving
        for (let i = 0; i < terrainPoints.length; i++) {
            terrainPoints[i].x -= 5;
        }
        for (let i = 0; i < world.bodies.length; i++) {
            Matter.Body.translate(world.bodies[i], frame_vec, true);
        }
        // Matter.Body.translate(wheel, {x: 0, y: 0});

        // Update dummy body to follow the terrain
        Matter.Body.setPosition(dummy, {
            x: wheel.position.x,
            y: two.height - terrainPoints[Math.floor(terrainPoints.length / 2)].y
        });
        two.update()

        noise_x += noise_step;
    }
    requestAnimationFrame(animate);

</script>

</html>